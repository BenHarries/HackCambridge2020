<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Requiblack meta tags -->
    <meta charset="utf-8"/>
    <meta
            name="viewport"
            content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />

    <!-- Bootstrap CSS -->
    <link
            rel="stylesheet"
            href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
            integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
            crossorigin="anonymous"
    />

    <title>Hack Cambridge 2020</title>

    <style>
        div.scrollmenu {
            background-color: rgb(201, 201, 201);
            overflow: auto;
            white-space: nowrap;
        }

        div.scrollmenu a {
            display: inline-block;
            color: white;
            text-align: center;
            padding: 14px;
            text-decoration: none;
        }

        div.scrollmenu a:hover {
            background-color: #777;
        }

        div.scrollmenu a:active {
            background-color: #777;
        }
    </style>

    <!-- FontAwesome -->
    <script src="https://kit.fontawesome.com/dbea95f351.js" crossorigin="anonymous"></script>
    <script src="./index.js"></script>

</head>

<body>
<!-- Heading -->
<nav class="navbar navbar-light bg-light">
    <span class="navbar-brand mb-0 h1 ">Hack Cambridge 2020</span>
    <a class="nav-link" href="https://github.com/BenHarries/HackCambridge2020" target="_blank"> <i
            class="fas fa-external-link-alt fa-2x"></i> </i></a>
</nav>

<!-- Words / Selector Split -->
<div class="container">
    <div class="row" style="padding-top: 20px;">
        <!-- Words -->
        <div class="col-8">

            <span id="words">hello my name is ben</span>

        </div>

        <!-- Selector Split -->
        <div class="col-4" id="Selector">
            <!-- Card -->
            <div
                    class="card border-info mb-3"
                    style="max-width: 18rem;"
            >
                <button
                        type="button"
                        class="btn btn-success btn-lg btn-block"
                        id="speechsdkStartContinuousRecognition"
                >
                    Start
                </button>
                <div class="card-body text-info">
                    <div id="label-container"></div>
                    <div id="filler-label-container">
                        <div class="progress">
                            <div
                                    class="progress-bar progress-bar-striped}"
                                    role="progressbar"
                                    aria-valuenow="0"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                            ></div>
                        </div>
                        <br/>
                        <div class="progress">
                            <div
                                    class="progress-bar progress-bar-striped}"
                                    role="progressbar"
                                    aria-valuenow="0"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                            ></div>
                        </div>
                        <br/>
                        <div class="progress">
                            <div
                                    class="progress-bar progress-bar-striped}"
                                    role="progressbar"
                                    aria-valuenow="0"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                            ></div>
                        </div>
                        <br/>
                        <div class="progress">
                            <div
                                    class="progress-bar progress-bar-striped}"
                                    role="progressbar"
                                    aria-valuenow="0"
                                    aria-valuemin="0"
                                    aria-valuemax="100"
                            ></div>
                        </div>
                    </div>
                </div>

                <div
                        class="card-footer bg-transparent border-info text-info"
                        id="footer"
                >
                    Accuracy:
                </div>

                <div id="sequence"></div>
            </div>
        </div>
    </div>
</div>

<style>
    .char-green {
        color: green;
    }

    .char-black {
        color: black;
    }
</style>

<script>


//    function changeColour(currentWord) {
//        document.getElementById(currentWord).className = "char-green";
//
//    };
//
//    function addInNewSentence(currentWordCount) {
//        var new_words = "Here";
//        var span = document.getElementById('words'),
//            text = new_words.split(' ').map((el, i) => {
//                // console.log(i,currentWordCount);
//                var a = parseInt(i) + parseInt(currentWordCount);
//                return '<span class="char-' + 'black' + '" id = "' + a + '">' + el + ' ' + '</span>';
//            }).join('');
//        console.log(span);
//        span.innerHTML += text;
//    }
//
//    var span = document.getElementById('words'),
//        text = span.innerHTML.split(' ').map((el, i) => {
//            return '<span class="char-' + 'black' + '" id = "' + i + '">' + el + ' ' + '</span>';
//        }).join('');
//    console.log(span);
//    span.innerHTML = text;
//
//
//    var currentWord = 0;
//    currentWordCount = document.getElementById('words').children.length;
//    var newWord = 0
//
//    function add_word() {
//        console.log(currentWord, document.getElementById('words').children.length);
//        if ("Here " == document.getElementById(newWord).innerHTML) {
//            console.log("true");
//
//            changeColour(newWord.toString());
//            currentWord += 1;
//            newWord += 1;
//
//        }
//        if (currentWord) {
//            addInNewSentence(currentWordCount + newWord - 1);
//            currentWord -= 1;
//            setTimeout(() => {
//                add_word()
//            }, 1000)
//            //sleep(() => {console.log('asdf')}, 1000); //.then( () => {(addInNewSentence(currentWordCount))});
//
//        }
//
//
//
//
//    }
//
//    add_word();


</script>

//     <!-- jQuery first, then Popper.js, then Bootstrap JS -->
<script
        src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
        integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
        crossorigin="anonymous"
></script>
<script
        src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
        integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
        crossorigin="anonymous"
></script>
<script
        src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
        integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
        crossorigin="anonymous"
></script>

<div id="content" style="display:none">
    <table>

        <tr>
            <td align="right"></td>
            <td>
<!--                <button id="speechsdkStartContinuousRecognition">startContinuousRecognitionAsync()</button>-->
<!--                <button id="speechsdkStopContinuousRecognition" disabled="disabled">STOP stopContinuousRecognitionAsync()</button>-->
            </td>
        </tr>


        </tr>
        <tr>
            <td align="right">Results:</td>
            <td align="left">
                <textarea id="phraseDiv" style="display: inline-block;width:200px;height:200px"></textarea>
            </td>
        </tr>
        <tr>
            <td align="right"></td>
            <td align="left"><textarea id="statusDiv" style="display: inline-block;width:200px;height:200px;overflow: scroll;white-space: nowrap;"></textarea></td>
        </tr>
    </table>
</div>

<!-- Speech SDK REFERENCE -->
<script src="microsoft.cognitiveservices.speech.sdk.bundle.js"></script>

<!-- Speech Speech SDK Authorization token -->
<script>
    // Note: Replace the URL with a valid endpoint to retrieve
    //       authorization tokens for your subscription.

    // An authorization token is a more secure method to authenticate for a browser deployment as
    // it allows the subscription keys to be kept secure on a server and a 10 minute use token to be
    // handed out to clients from an endpoint that can be protected from unauthorized access.

</script>

<!-- Speech SDK USAGE -->
<script>
    // On document load resolve the Speech SDK dependency
    function Initialize(onComplete) {
        if (!!window.SpeechSDK) {
            document.getElementById('content').style.display = 'block';
            // document.getElementById('warning').style.display = 'none';
            onComplete(window.SpeechSDK);
        }
    }

    function compareText(readPhrase) {
        var samplePhrase = "I like to eat chips";
        samplePhrase.replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g,"");
        samplePhrase.replace(/\s{2,}/g," ");

        console.log(str.split(samplePhrase, " "));


    }
</script>

<!-- Browser Hooks -->
<script>
    let angus = " ";
    var phraseDiv, statusDiv;
    var phrases;
    var SpeechSDK;
    var recognizer;

    var reco;
    var sdkStartContinousRecognitionBtn, sdkStopContinousRecognitionBtn;
    var voiceOutput;

    var soundContext = undefined;
    try {
        var AudioContext = window.AudioContext // our preferred impl
            || window.webkitAudioContext       // fallback, mostly when on Safari
            || false;                          // could not find.

        if (AudioContext) {
            soundContext = new AudioContext();
        } else {
            alert("Audio context not supported");
        }
    }
    catch (e) {
        window.console.log("no sound context found, no audio output. " + e);
    }

    document.addEventListener("DOMContentLoaded", function () {
        createBtn = document.getElementById("createBtn");
        sdkStartContinousRecognitionBtn = document.getElementById("speechsdkStartContinuousRecognition");
        sdkStopContinousRecognitionBtn = document.getElementById("speechsdkStopContinuousRecognition");
        phraseDiv = document.getElementById("phraseDiv");
        statusDiv = document.getElementById("statusDiv");
        phrases = document.getElementById("phrases");
        voiceOutput = document.getElementById("voiceOutput");

        // Starts continuous speech recognition.
        sdkStartContinousRecognitionBtn.addEventListener("click", function () {
            phraseDiv.innerHTML = "";
            statusDiv.innerHTML = "";
            var lastRecognized = "";

            // If an audio file was specified, use it. Else use the microphone.
            // Depending on browser security settings, the user may be prompted to allow microphone use. Using continuous recognition allows multiple
            // phrases to be recognized from a single use authorization.
            var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

            var speechConfig;
            speechConfig = SpeechSDK.SpeechConfig.fromSubscription("f9bef20c5e064a65b33c3467e56f8e8b", "westus");

            speechConfig.speechRecognitionLanguage = 'en-US';
            reco = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

            // Before beginning speech recognition, setup the callbacks to be invoked when an event occurs.

            // The event recognizing signals that an intermediate recognition result is received.
            // You will receive one or more recognizing events as a speech phrase is recognized, with each containing
            // more recognized speech. The event will contain the text for the recognition since the last phrase was recognized.
            reco.recognizing = function (s, e) {
                window.console.log(e);
                statusDiv.innerHTML += "(recognizing) Reason: " + SpeechSDK.ResultReason[e.result.reason] + " Text: " + e.result.text + "\r\n";
                phraseDiv.innerHTML = lastRecognized + e.result.text;
                console.log(lastRecognized + e.result.text, "angus");
                angus = lastRecognized + e.result.text;
                add_word()


            };

            // The event recognized signals that a final recognition result is received.
            // This is the final event that a phrase has been recognized.
            // For continuous recognition, you will get one recognized event for each phrase recognized.
            reco.recognized = function (s, e) {
                window.console.log(e);

                // Indicates that recognizable speech was not detected, and that recognition is done.
                if (e.result.reason === SpeechSDK.ResultReason.NoMatch) {
                    var noMatchDetail = SpeechSDK.NoMatchDetails.fromResult(e.result);
                    statusDiv.innerHTML += "(recognized)  Reason: " + SpeechSDK.ResultReason[e.result.reason] + " NoMatchReason: " + SpeechSDK.NoMatchReason[noMatchDetail.reason] + "\r\n";
                } else {
                    statusDiv.innerHTML += "(recognized)  Reason: " + SpeechSDK.ResultReason[e.result.reason] + " Text: " + e.result.text + "\r\n";
                    console.log('recognised');
                    compareText(e.result.text);
                }

                lastRecognized += e.result.text + "\r\n";
                phraseDiv.innerHTML = lastRecognized;
            };

            // The event signals that the service has stopped processing speech.
            // https://docs.microsoft.com/javascript/api/microsoft-cognitiveservices-speech-sdk/speechrecognitioncanceledeventargs?view=azure-node-latest
            // This can happen for two broad classes of reasons.
            // 1. An error is encountered.
            //    In this case the .errorDetails property will contain a textual representation of the error.
            // 2. No additional audio is available.
            //    Caused by the input stream being closed or reaching the end of an audio file.
            reco.canceled = function (s, e) {
                window.console.log(e);

                statusDiv.innerHTML += "(cancel) Reason: " + SpeechSDK.CancellationReason[e.reason];
                if (e.reason === SpeechSDK.CancellationReason.Error) {
                    statusDiv.innerHTML += ": " + e.errorDetails;
                }
                statusDiv.innerHTML += "\r\n";
            };

            // Signals that a new session has started with the speech service
            reco.sessionStarted = function (s, e) {
                window.console.log(e);
                statusDiv.innerHTML += "(sessionStarted) SessionId: " + e.sessionId + "\r\n";
            };

            // Signals the end of a session with the speech service.
            reco.sessionStopped = function (s, e) {
                window.console.log(e);
                statusDiv.innerHTML += "(sessionStopped) SessionId: " + e.sessionId + "\r\n";
                sdkStartContinousRecognitionBtn.disabled = false;
                sdkStopContinousRecognitionBtn.disabled = true;
            };

            // Signals that the speech service has started to detect speech.
            reco.speechStartDetected = function (s, e) {
                window.console.log(e);
                statusDiv.innerHTML += "(speechStartDetected) SessionId: " + e.sessionId + "\r\n";
            };

            // Signals that the speech service has detected that speech has stopped.
            reco.speechEndDetected = function (s, e) {
                window.console.log(e);
                statusDiv.innerHTML += "(speechEndDetected) SessionId: " + e.sessionId + "\r\n";
            };

            // Starts recognition
            reco.startContinuousRecognitionAsync();

            sdkStartContinousRecognitionBtn.disabled = true;
            // sdkStopContinousRecognitionBtn.disabled = false;
        });

        // Stops recognition and disposes of resources.
        // sdkStopContinousRecognitionBtn.addEventListener("click", function () {
        //     reco.stopContinuousRecognitionAsync(
        //         function () {
        //             reco.close();
        //             reco = undefined;
        //         },
        //         function (err) {
        //             reco.close();
        //             reco = undefined;
        //         });
        //
        //     sdkStartContinousRecognitionBtn.disabled = false;
        //     sdkStopContinousRecognitionBtn.disabled = true;
        // });







        // If an audio file was specified, use it. Else use the microphone.
        // Depending on browser security settings, the user may be prompted to allow microphone use. Using continuous recognition allows multiple
        // phrases to be recognized from a single use authorization.
        var audioConfig = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
        var speechConfig;
        speechConfig = SpeechSDK.SpeechConfig.fromSubscription("f9bef20c5e064a65b33c3467e56f8e8b", "westus");

        speechConfig.speechRecognitionLanguage = "en-US";
        reco = new SpeechSDK.IntentRecognizer(speechConfig, audioConfig);

        // Set up a Language Understanding Model from Language Understanding Intelligent Service (LUIS).
        // See https://www.luis.ai/home for more information on LUIS.


        // Before beginning speech recognition, setup the callbacks to be invoked when an event occurs.

        // The event recognizing signals that an intermediate recognition result is received.
        // You will receive one or more recognizing events as a speech phrase is recognized, with each containing
        // more recognized speech. The event will contain the text for the recognition since the last phrase was recognized.
        reco.recognizing = function (s, e) {
            window.console.log(e);
            statusDiv.innerHTML += "(recognizing) Reason: " + SpeechSDK.ResultReason[e.result.reason] + " Text: " + e.result.text + "\r\n";
            phraseDiv.innerHTML = e.result.text;
        };

        // The event signals that the service has stopped processing speech.
        // https://docs.microsoft.com/javascript/api/microsoft-cognitiveservices-speech-sdk/speechrecognitioncanceledeventargs?view=azure-node-latest
        // This can happen for two broad classes or reasons.
        // 1. An error is encountered.
        //    In this case the .errorDetails property will contain a textual representation of the error.
        // 2. No additional audio is available.
        //    Caused by the input stream being closed or reaching the end of an audio file.
        reco.canceled = function (s, e) {
            window.console.log(e);

            statusDiv.innerHTML += "(cancel) Reason: " + SpeechSDK.CancellationReason[e.reason];
            if (e.reason === SpeechSDK.CancellationReason.Error) {
                statusDiv.innerHTML += ": " + e.errorDetails;
            }
            statusDiv.innerHTML += "\r\n";
        };

        // The event recognized signals that a final recognition result is received.
        // This is the final event that a phrase has been recognized.
        // For continuous recognition, you will get one recognized event for each phrase recognized.
        reco.recognized = function (s, e) {
            window.console.log(e);

            statusDiv.innerHTML += "(recognized)  Reason: " + SpeechSDK.ResultReason[e.result.reason];

            // Depending on what result reason is returned, different properties will be populated.
            switch (e.result.reason) {
                // This case occurs when speech was successfully recognized, but the speech did not match an intent from the Language Understanding Model.
                case SpeechSDK.ResultReason.RecognizedSpeech:
                    statusDiv.innerHTML += " Text: " + e.result.text;
                    break;

                // Both speech an intent from the model was recognized.
                case SpeechSDK.ResultReason.RecognizedIntent:
                    statusDiv.innerHTML += " Text: " + e.result.text + " IntentId: " + e.result.intentId;

                    // The actual JSON returned from Language Understanding is a bit more complex to get to, but it is available for things like
                    // the entity name and type if part of the intent.
                    statusDiv.innerHTML += " Intent JSON: " + e.result.properties.getProperty(SpeechSDK.PropertyId.LanguageUnderstandingServiceResponse_JsonResult);
                    break;

                // No match was found.
                case SpeechSDK.ResultReason.NoMatch:
                    var noMatchDetail = SpeechSDK.NoMatchDetails.fromResult(e.result);
                    statusDiv.innerHTML += " NoMatchReason: " + SpeechSDK.NoMatchReason[noMatchDetail.reason];
                    break;
            }
            statusDiv.innerHTML += "\r\n";
        };

        // Signals that a new session has started with the speech service
        reco.sessionStarted = function (s, e) {
            window.console.log(e);
            statusDiv.innerHTML += "(sessionStarted) SessionId: " + e.sessionId + "\r\n";
        };

        // Signals the end of a session with the speech service.
        reco.sessionStopped = function (s, e) {
            window.console.log(e);
            statusDiv.innerHTML += "(sessionStopped) SessionId: " + e.sessionId + "\r\n";
            sdkStartContinousRecognitionBtn.disabled = false;
            sdkStopContinousRecognitionBtn.disabled = true;
        };

        // Signals that the speech service has started to detect speech.
        reco.speechStartDetected = function (s, e) {
            window.console.log(e);
            statusDiv.innerHTML += "(speechStartDetected) SessionId: " + e.sessionId + "\r\n";
        };

        // Signals that the speech service has detected that speech has stopped.
        reco.speechEndDetected = function (s, e) {
            window.console.log(e);
            statusDiv.innerHTML += "(speechEndDetected) SessionId: " + e.sessionId + "\r\n";
        };

        // Note: this is how you can process the result directly
        //       rather then subscribing to the recognized
        //       event


        Initialize(function (speechSdk) {
            SpeechSDK = speechSdk;
        });
    });




    function changeColour(currentWord) {
        document.getElementById(currentWord).className = "char-green";

    };

    function addInNewSentence(currentWordCount) {
        var new_words = "i enjoy pizza";
        var span = document.getElementById('words'),
            text = new_words.split(' ').map((el, i) => {
                // console.log(i,currentWordCount);
                var a = parseInt(i) + parseInt(currentWordCount);
                return '<span class="char-' + 'black' + '" id = "' + a + '">' + el + ' ' + '</span>';
            }).join('');
        console.log(span);
        span.innerHTML += text;
        return (new_words.split(' ').length)
    }

    var span = document.getElementById('words'),
        text = span.innerHTML.split(' ').map((el, i) => {
            return '<span class="char-' + 'black' + '" id = "' + i + '">' + el + ' ' + '</span>';
        }).join('');
    console.log(span);
    span.innerHTML = text;

    var incorrectWords = new Set()
    var currentWord = 0;
    currentWordCount = document.getElementById('words').children.length;
    var newWord = 0;
    var lengthPrevSentence = 5;
    function add_word() {
        console.log(document.getElementById(newWord).innerHTML, newWord, "hellll");
        if ((angus + " ").includes(document.getElementById(newWord).innerHTML)) {
            console.log("true");
            incorrectWords.delete(document.getElementById(newWord).innerHTML)
            console.log(incorrectWords, "Correct")
            changeColour(newWord.toString());
            currentWord += 1;
            newWord += 1;

        } else {
            incorrectWords.add(document.getElementById(newWord).innerHTML)
            console.log(incorrectWords, "INCORRECT")
        }
        if (currentWord >= lengthPrevSentence) {
            lengthPrevSentence = addInNewSentence(newWord);
            currentWord = 0;
            // setTimeout(() => {
            //     add_word()
            // }, 1000)
            //sleep(() => {console.log('asdf')}, 1000); //.then( () => {(addInNewSentence(currentWordCount))});

        }




    }

    // add_word();
</script>
</body>
</html>
